\documentclass{beamer}

\usecolortheme{seagull}
\usefonttheme{structurebold}

\usepackage[utf8]{inputenc}
\usepackage[swedish]{babel}

\usepackage{roboto}
\usepackage[scaled=0.9]{roboto-mono}
\usepackage[T1]{fontenc}

\usepackage{icomma}
\usepackage{minted} % code with syntax highlighting
\usepackage[normalem]{ulem} % strikethrought
\usepackage{url}

\title{Seminarium 02}
\subtitle{Experimentering}
\date{14 september 2021}
\author{Gustav Sörnäs}

\setlength{\parskip}{1em}
\renewcommand{\baselinestretch}{1.2}

\AtBeginSection[] % Do nothing for \section*
{
\begin{frame}<beamer>
\frametitle{Planering}
\tableofcontents[currentsection]
\end{frame}
}

\begin{document}
  \frame{\titlepage}

  \begin{frame}
    \frametitle{Seminarieformen}

    Mer fokus på eget kodskrivande än ''Ett steg i taget'', men mer konkret än
    ''Diskussion och analys''.

    Fritt fram att byta spår under terminen.

    Innan seminariet: läs förberedelsematerialet och försök er på uppgifterna.

    Skicka in lösningar så vi kan diskutera i helklass:
    \texttt{seminarium.sörnäs.se}. Anonymt, sålänge du inte skriver ditt namn i
    koden :)

  \end{frame}

  \begin{frame}
    \frametitle{Dagens seminarium}

    \begin{itemize}
      \item Datatyper
      \item Uppgift: iteration
      \item \sout{Fysisk rekursion}
      \item Analys: tupler och rekursion
      \item Uppgift: palindrom
      \item Analys: dictionaries
      \item Diskussion
    \end{itemize}

  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Datatyper -- Enkla datatyper}

    \pause{}

    \begin{itemize}
      \item Strängar (\texttt{str})
      \pause{}

      \item Tal (\texttt{int}/\texttt{float})
      \pause{}

        Tänk på att flyttal har en maxgräns (\(1,8 \cdot 10^{308}\)) \\
        \pause{}
        och riskerar avrundningsfel:
        \pause{}

\begin{verbatim}
>>> (0.1 + 0.2) * 10 == 3.0
\end{verbatim}
\vspace{-0.5em}
\pause{}
\begin{verbatim}
False
\end{verbatim}
\pause{}
\begin{verbatim}
>>> 0.1 + 0.2
0.30000000000000004
\end{verbatim}
\vspace{-0.5em}

      \pause{}
      \item Sanningsvärden (\texttt{bool})

      \pause{}
      \item Null-värdet (\texttt{None})

    \end{itemize}

  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Datatyper -- Sammansatta datatyper}

    \pause{}

    \begin{itemize}
      \item Listor

      Sparar en hög med element (inte nödvändigtvis av samma datatyp).

      \pause{}

      \item Tupler

      Som listor, men de går inte att modifiera.

      \pause{}

      \item Dictionaries

      Associerar ett värde till en nyckel. Typ som en lista som du ''indexerar''
      med något arbiträrt.

    \end{itemize}

    \pause{}

    \begin{minted}{python}
>>> fruit_colors = {"banan": "gul", "äpple": "grön"}
>>> fruit_colors["banan"]
"gul"
    \end{minted}


  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Uppgift: \texttt{find\_uncut}}

    Om \texttt{True} är en klippt gräsruta och \texttt{False} är en oklippt
    gräsruta, returnera en lista över alla oklippta rutors koordinater.

    \begin{minted}{python}
>>> find_uncut([
...     [True,  False, True,  False],
...     [False, False, True,  True],
...     [True,  False, False, True],
...     [False, True,  True,  True]
... ])
...
[(1, 0), (3, 0), (0, 1), (1, 1), (2, 1), (2, 2), (0, 3)]
    \end{minted}

    \texttt{seminarium.sörnäs.se}

  \end{frame}

  \begin{frame}[fragile]
    \frametitle{\texttt{min\_max}}

    \begin{columns}
      \begin{column}{0.48\textwidth}
        \begin{minted}[fontsize=\scriptsize,linenos]{python}
def min_max(seq):
    if not seq:
        return (None, None)
    if len(seq) == 1:
        return (seq[0], seq[0])

    (l_min, l_max) = min_max(seq[1:])

    if seq[0] < l_min:
        l_min = seq[0]
    if seq[0] > l_max:
        l_max = seq[0]

    print("min: ", l_min)
    print("max: ", l_max)

    return (l_min, l_max)
        \end{minted}

        % Basfall 1: tom lista => (None, None)
        % Basfall 2: [elem] => (elem, elem)
        % (l_min, l_max) på tail
        % Jämför med head.
        %  Om head < l_min, l_min = head.
        %  Om head > l_max, l_max = head.
        % => (l_min, l_max)
        %
        % Tänk på steget innan basfallet, alltså när det finns två element i
        % listan. Ta [1,2,3] som exempel. Rekursivt anrop från näst sista steget
        % (när vi har [2,3]) ger l_min = l_max = 3. Vi jämför med head och får
        % 2 < 3 men not 2 > 3, så nya värden är l_min=2 och l_max=3.
        % Rekursionen bakåt ger sedan l_min=1 och l_max=3.

      \end{column}%
      \begin{column}{0.48\textwidth}
        \begin{enumerate}
          \item Funktionen körs med \\ \texttt{[1, 2, 3]} som indata. Vad skrivs ut? Vad returneras?
          \item Fungerar \texttt{[1, 2, 'abc']} som indata?
          \item Fungerar \texttt{(1, 2, 3)} som indata?
        \end{enumerate}
      \end{column}
    \end{columns}

  \end{frame}

  \begin{frame}
    \frametitle{Hur en rekursiv funktion kan analyseras}

    \begin{itemize}
      \item Vad är basfallen?
      \item Hur delas problemet upp i samma problem i mindre delar?
      \item Hur sätts de mindre delarna ihop till grundproblemet?
    \end{itemize}

  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Exempel på analys av rekursiv funktion: \texttt{min\_max}}

    \begin{columns}
      \begin{column}{0.48\textwidth}
        \begin{minted}[fontsize=\scriptsize,linenos]{python}
def min_max(seq):
    if not seq:
        return (None, None)
    if len(seq) == 1:
        return (seq[0], seq[0])

    (l_min, l_max) = min_max(seq[1:])

    if seq[0] < l_min:
        l_min = seq[0]
    if seq[0] > l_max:
        l_max = seq[0]

    print("min: ", l_min)
    print("max: ", l_max)

    return (l_min, l_max)
        \end{minted}

      \end{column}%
      \begin{column}{0.48\textwidth}
        \only<1> {Vad är basfallen?}%
        \only<2> {Hur delas problemet upp i samma problem i mindre delar?}%
        \only<3> {Hur sätts de mindre delarna ihop till grundproblemet?}%
      \end{column}
    \end{columns}

  \end{frame}

  \begin{frame}

    \begin{center}
      \Huge Paus?
    \end{center}

  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Uppgift: palindrom}

    Skriv två funktioner (en iterativ och en rekursiv) som tar en sträng och
    returnerar huruvida strängen är ett palindrom eller inte.

    Ett palindrom är ett ord som skrivs likadant framlänges som baklänges.
    Exempel: ABBA, kajak.

  \end{frame}

  \begin{frame}
    \frametitle{Hur en rekursiv funktion kan designas}

    \begin{itemize}
      \item Vad är basfallen?
      \item Hur kan problemet delas upp i samma problem i mindre delar?
      \item Hur sätts de mindre delarna ihop till grundproblemet?
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]
    \frametitle{Exempel på en rekursiv funktion: \texttt{palin\_rec}}

    \begin{minted}{python}
def palin_rec(s):
    \end{minted}
    \vspace{-1.5em}
    \pause{}
    \begin{minted}{python}
    if len(s) <= 1:
        return True
    \end{minted}
    \vspace{-1.5em}
    \pause{}
    \begin{minted}{python}
    return palin_rec(s[1:-1]) \
    \end{minted}
    \vspace{-1.5em}
    \pause{}
    \begin{minted}{python}
            and s[0] == s[-1]
    \end{minted}

    \pause{}

    ABBA

    kajak

  \end{frame}

  \begin{frame}[fragile]

    Iterativt blir det att vi beskriver \emph{hur} snarare än
    \emph{vad}.

    \begin{minted}{python}
def palin_iter(s):
    \end{minted}
    \vspace{-1.5em}
    \pause{}
    \begin{minted}{python}
    mid = len(s) // 2
    \end{minted}
    \vspace{-1.5em}
    \pause{}
    \begin{minted}{python}
    for i in range(mid):
    \end{minted}
    \vspace{-1.5em}
    \pause{}
    \begin{minted}{python}
        if s[i] != s[-(i + 1)]:
    \end{minted}
    \vspace{-1.5em}
    \pause{}
    \begin{minted}{python}
            return False
    \end{minted}
    \vspace{-1.5em}
    \pause{}
    \begin{minted}{python}
    return True
    \end{minted}

  \end{frame}

  \begin{frame}
    \frametitle{Allmänt om rekursion}

    Väldigt bra på att lösa vissa typer av problem, främst problem som
    innehåller rekursiva strukturer. Exempel: trädstrukturer och uttrycksparsing
    (båda i labb 4).

    Föredrog ni \texttt{palin\_rec} eller \texttt{palin\_iter}? Var den ena
    lättare än den andra att skriva / förstå? (Inte nödvändigtvis samma sak.)

  \end{frame}

  \begin{frame}[fragile]
    \frametitle{\texttt{dict\_func}}

    Vad gör den här funktionen?

    \begin{minted}[linenos]{python}
def dict_func(d):
    result = {}

    for key in d:
        if d[key] in result:
            result[d[key]].append(key)
        else:
            result[d[key]] = [key]
    return result
    \end{minted}

  \end{frame}

  \begin{frame}
    \frametitle{Talbaser -- decimala tal}

    \(1234 \pause{} = \underset{\times 10^3}{1} \pause{}\ \underset{\times 10^2}{2} \pause{}\ \underset{\times 10^1}{3} \pause{}\ \underset{\times 10^0}{4} \pause{} = 1 \cdot 10^3 \pause{} + 2 \cdot 10^2 \pause{} + 3 \cdot 10^1 \pause{} + 4 \cdot 10^0\)

    \pause{}

    Decimalt talsystem: 10 siffror (0-9)

  \end{frame}

  \begin{frame}
    \frametitle{Talbaser -- binära tal}

    Binärt talsystem: 2 siffror (0-1)

    \pause{}

    \(101010\pause{}_2 \pause{} = \underset{\times 2^5}{1} \pause{}\ \underset{\times 2^4}{0} \pause{}\ \underset{\times 2^3}{1} \pause{}\ \underset{\times 2^2}{0} \pause{}\ \underset{\times 2^1}{1} \pause{}\ \underset{\times 2^0}{0}\)

    \pause{}

    \vspace{-0.5em}

    \(= 2^5 \pause{} + 2^3 \pause{} + 2^1 \pause{} = 32 + 8 + 2 \pause{} = 42\pause{}_{10}\)

  \end{frame}

  \begin{frame}
    \frametitle{Talbaser -- Decimala decimaltal}

    \pause{}

    Fortsätter åt höger med negativa exponenter

    \pause{}

    \(12,34 \pause{} = \underset{\times 10^1}{1} \pause{}\ \underset{\times 10^0}{2} \pause{}\ , \pause{}\ \underset{\times 10^{-1}}{3} \pause{}\ \underset{\times 10^{-2}}{4} \pause{} = 1 \cdot 10 \pause{} + 2 \cdot 1 \pause{} + 3 \cdot 0,1 \pause{} + 4 \cdot 0,01\)

  \end{frame}

  \begin{frame}
    \frametitle{Talbaser -- Binära decimaltal}

    \pause{}

    \(101,010_2 \pause{} = \underset{\times 2^2}{1} \pause{}\ \underset{\times 2^1}{0} \pause{}\ \underset{\times 2^0}{1} \pause{}\ , \pause{}\ \underset{\times 2^{-1}}{0} \pause{}\ \underset{\times 2^{-2}}{1} \pause{}\ \underset{\times 2^{-3}}{0}\)

    \pause{}

    \vspace{-0.5em}

    \(= 2^2 + 2^0 + 2^{-2} = 4 + 1 + 0,25 = 5,25 \)

    \pause{}

    Vissa tal \(\in \ ]0, 1[\) går inte att representera exakt med ett binärt
    talsystem, på samma sätt som \(\frac{1}{3}\) inte går att representera exakt
    med ett decimalt talsystem (\(0,333\dots\)).

    \pause{}

    Flyttal i datorsystem är lite annorlunda (IEEE 754) men poängen kvarstår.

  \end{frame}

\end{document}
